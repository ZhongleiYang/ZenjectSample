<p><img src="Documentation/ZenjectLogo.png?raw=true" alt="Zenject" width="600px" height="134px"/></p>
<h1 id="dependency-injection-framework-for-unity3d">Dependency Injection Framework for Unity3D</h1>
<h2 id="table-of-contents">Table Of Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#history">History</a></li>
<li>Dependency Injection<ul>
<li><a href="#theory">Theory</a></li>
<li><a href="#misconceptions">Misconceptions</a></li>
</ul>
</li>
<li>Zenject API<ul>
<li><a href="#getting_started">Getting Started</a></li>
<li><a href="#zenject_overview">API Overview</a></li>
<li><a href="#composition_root"/>Composition Root</a></li>
<li><a href="#dependency_root">Dependency Root</a></li>
<li><a href="#rules">Rules</a></li>
<li><a href="#tickables">ITickable &amp; IInitializable</a></li>
<li><a href="#hello_world">Hello World</a></li>
<li><a href="#update_order">Update Order And Initialization Order</a></li>
<li><a href="#across_scenes">Injecting Data Across Scenes</a></li>
<li><a href="#automocking">Auto-Mocking</a></li>
<li><a href="#graphviz">Visualizing Your Object Graph</a></li>
</ul>
</li>
<li>FAQ<ul>
<li><a href="#strange">How is this different from Strange IoC?</a></li>
<li>More to come!</li>
</ul>
</li>
</ul>
<h2 id="wzxhzdk1wzxhzdk2introduction"><a id="introduction"></a>Introduction</h2>
<p>Zenject is a lightweight dependency injection framework built specifically to target Unity 3D.  It can be used to turn your Unity 3D application into a collection of loosely-coupled parts with highly segmented responsibilities.  Zenject can then glue the parts together in many different configurations to allow you to easily write, re-use, refactor and test your code in a scalable and extremely flexible way.</p>
<p>This project is open source.  You can find the official repository <a href="https://github.com/modesttree/Zenject">here</a>.  If you would like to contribute to the project pull requests are welcome!</p>
<p>For general support or bug requests, please feel free to create issues on the github page.  You can also email me directly at svermeulen@modesttree.com</p>
<h2 id="wzxhzdk3wzxhzdk4features"><a id="features"></a>Features</h2>
<ul>
<li>Injection into normal C# classes or MonoBehaviours</li>
<li>Constructor injection (can tag constructor if there are multiple)</li>
<li>Field injection</li>
<li>Property injection</li>
<li>Named injections (string, enum, etc.)</li>
<li>Auto-Mocking using the Moq library</li>
<li>Injection across different Unity scenes</li>
<li>Ability to print entire object graph as a UML image automatically</li>
</ul>
<h2 id="wzxhzdk5wzxhzdk6history"><a id="history"></a>History</h2>
<p>Unity is a fantastic game engine, however the approach that new developers are encouraged to take does not lend itself well to writing large, flexible, or scalable code bases.  In particular, the default way that Unity manages dependencies between different game components can often be awkward and error prone.</p>
<p>Having worked on non-unity projects that use dependency management frameworks (such as Ninject, which Zenject takes a lot of inspiration from), the problem irked me enough that I decided a custom framework was in order.  Upon googling for solutions, I found a series of great articles by Sebastiano Mandal√† outlining the problem, which I strongly recommend that everyone read before firing up Zenject:</p>
<ul>
<li><a href="http://blog.sebaslab.com/ioc-container-for-unity3d-part-1/">http://blog.sebaslab.com/ioc-container-for-unity3d-part-1/</a></li>
<li><a href="http://blog.sebaslab.com/ioc-container-for-unity3d-part-2/">http://blog.sebaslab.com/ioc-container-for-unity3d-part-2/</a></li>
</ul>
<p>Sebastiano even wrote a proof of concept and open sourced it, which became the basis for this library.</p>
<p>What follows in the next section is a general overview of Dependency Injection from my perspective.  I highly recommend seeking other resources for more information on the subject, as there are many (often more intelligent) people that have written on the subject.  In particular, I highly recommend anything written by Mark Seeman on the subject - in particular his book 'Dependency Injection in .NET'.</p>
<p>Finally, I will just say that if you don't have experience with DI frameworks, and are writing object oriented code, then trust me, you will thank me later!  Once you learn how to write properly loosely coupled code using DI, there is simply no going back.</p>
<h2 id="wzxhzdk7wzxhzdk8theory"><a id="theory"></a>Theory</h2>
<p>When writing an individual class to achieve some functionality, it will likely need to interact with other classes in the system to achieve its goals.  One way to do this is to have the class itself create its dependencies, by calling concrete constructors:</p>
<pre><code>public class Foo
{
    ISomeService _service;

    public Foo()
    {
        _service = new SomeService();
    }

    public void DoSomething()
    {
        _service.PerformTask();
        ...
    }
}
</code></pre>
<p>This works fine for small projects, but as your project grows it starts to get unwieldy.  The class Foo is tightly coupled to class 'SomeService'.  If we decide later that we want to use a different concrete implementation then we have to go back into the Foo class to change it.</p>
<p>After thinking about this, often you come to the realization that ultimately, Foo shouldn't bother itself with the details of choosing the specific implementation of the service.  All Foo should care about is fulfilling its own specific responsibilities.  As long as the service fulfills the abstract interface required by Foo, Foo is happy.  Our class then becomes:</p>
<pre><code>public class Foo
{
    ISomeService _service;

    public Foo(ISomeService service)
    {
        _service = service;
    }

    public void DoSomething()
    {
        _service.PerformTask();
        ...
    }
}
</code></pre>
<p>This is better, but now whatever class is creating Foo (let's call it Bar) has the problem of filling in Foo's extra dependencies:</p>
<pre><code>public class Bar
{
    public void DoSomething()
    {
        var foo = new Foo(new SomeService());
        foo.DoSomething();
        ...
    }
}
</code></pre>
<p>And class Bar probably also doesn't really care about what specific implementation of SomeService Foo uses.  Therefore we push the dependency up again:</p>
<pre><code>public class Bar
{
    ISomeService _service;

    public Bar(ISomeService service)
    {
        _service = service;
    }

    public void DoSomething()
    {
        var foo = new Foo(_service);
        foo.DoSomething();
        ...
    }
}
</code></pre>
<p>So we find that it is useful to push the responsibility of deciding which specific implementations of which classes to use further and further up in the 'object graph' of the application.  Taking this to an extreme, we arrive at the entry point of the application, at which point all dependencies must be satisfied before things start.  The dependency injection lingo for this part of the application is called the 'composition root'.</p>
<h2 id="wzxhzdk9wzxhzdk10misconceptions"><a id="misconceptions"></a>Misconceptions</h2>
<p>There are many misconceptions about DI, due to the fact that it can be tricky to fully wrap your head around at first.  It will take time and experience before it fully 'clicks'.</p>
<p>As shown in the above example, DI can be used to easily swap different implementations of a given interface (in the example this was ISomeService).  However, this is only one of many benefits that DI offers.  In most cases the various responsibilities of an application have single, specific classes implementing them, so you will be injecting concrete references in those cases rather than interfaces (especially if you're like me and follow the <a href="http://codemanship.co.uk/parlezuml/blog/?postid=934">Reused Abstraction Principle</a>).</p>
<p>More important than that is the fact that using a dependency injection framework like Zenject allows you to more easily follow the '<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>'.  By letting Zenject worry about wiring up the classes, the classes themselves can just focus on fulfilling their specific responsibilities.</p>
<p>Other benefits include:</p>
<ul>
<li>Testability - Writing automated unit tests or user-driven tests becomes very easy, because it is just a matter of writing a different 'composition root' which wires up the dependencies in a different way.  Want to only test one subsystem?  Simply create a new composition root which creates 'mocks' for all other systems in the application. (more detail on this below)</li>
<li>Refactorability - When code is loosely coupled, as is the case when using DI properly, the entire code base is much more resilient to changes.  You can completely change parts of the code base without having those changes wreak havoc on other parts.</li>
<li>Encourages modular code - When using a DI framework you will naturally follow better design practices, because it forces you to think about the interfaces between classes.</li>
</ul>
<h2 id="wzxhzdk11wzxhzdk12how-should-i-get-started"><a id="getting_started"></a>How should I get started?</h2>
<p>Once you have an understanding of the theory behind Zenject (if not see the previous sections), then I recommend diving in to the included sample application to get started, by extracting the included unity package "ZenjectSampleGame.unitypackage" into your unity project.</p>
<h2 id="wzxhzdk13wzxhzdk14overview-of-the-zenject-api"><a id="zenject_overview"></a>Overview Of The Zenject API</h2>
<p>What follows is a general overview of how DI patterns are applied using Zenject.  However, the best documentation right now is probably the included sample project itself.  I would recommend using that for reference when reading over these concepts.</p>
<h2 id="wzxhzdk15wzxhzdk16composition-root-installers"><a id="composition_root"/></a>Composition Root / Installers</h2>
<p>If you look at the sample application (a kind of asteroids clone) you will see that at the top of the scene heirarchy (in scene 'Main') we have a game object with the name CompositionRoot.   This is where Zenject resolves all dependencies before kicking off your application.</p>
<p>To add dependency bindings to your application, you need to write what is referred to in Zenject as an 'Installer' which usually looks something like this:</p>
<pre><code>[Serializable]
public class GameInstaller : Installer
{
    public string SomeSetting;

    public override void RegisterBindings()
    {
        ...
        _container.Bind&lt;IDependencyRoot&gt;().ToSingle&lt;GameRoot&gt;();
        ...
    }
}

public class GameInstallerWrapper : InstallerMonoBehaviourWrapper&lt;GameInstaller&gt;
{
}
</code></pre>
<p>The RegisterBindings() method is called once at the entry point of the application by the composition root.  Note here that the Installer class is not a MonoBehaviour and therefore cannot be dragged onto unity game objects.  This is to allow installers to easily trigger other installers and also to allow installers to be used in non-unity contexts (eg: NUnit tests).  However, it is also very useful to be able to simply drag and drop different sets of installers into a given unity scene, which is why in many cases you will want to provide the extra wrapper class.</p>
<p>Once RegisterBindings() is called the installer can begin mapping out the object graph to be used in the application.  The syntax here will be familiar to users of many other DI frameworks.</p>
<p>Like many other DI frameworks, dependency mapping done by adding the binding to something called the container.  The container should then 'know' how to create all the object instances in our application, by recursively resolving all dependencies for a given object.  You can do this by calling the Resolve method:</p>
<pre><code>Foo foo = _container.Resolve&lt;Foo&gt;()
</code></pre>
<p>However, any use of the container should be restricted to the composition root or factory classes (see rules/guidelines section below)</p>
<h2 id="wzxhzdk17wzxhzdk18the-dependency-root"><a id="dependency_root"></a>The dependency root</h2>
<p>Every Zenject app has one root object.  The dependencies of this object generates the full object graph for the application/game.  For example, in the sample project this is the GameRoot class which is declared as below:</p>
<pre><code>_container.Bind&lt;IDependencyRoot&gt;().ToSingle&lt;GameRoot&gt;();
</code></pre>
<p>A Zenject driven application is executed by the following steps:</p>
<ul>
<li>Composition Root is started (via Awake() method)</li>
<li>Composition Root calls RegisterBindings() on all installers that are attached below it in the scene heirarchy</li>
<li>Each Installer registers different sets of dependencies directly on to the DiContainer by calling Bind&lt;&gt; and BindValue&lt;&gt; methods.  Note that the order that this binding occurs should not matter.</li>
<li>The Composition Root then traverses the scene heirarchy again and injects all MonoBehaviours with their dependencies.  Since MonoBehaviours are instantiated by Unity we cannot use constructor injection in this case and therefore field or property injection must be used (which is done by adding a [Inject] attribute to any member)</li>
<li>After filling in the scene dependencies the CR then calls <code>_container.Resolve</code> on the root object (that is, whatever is bound to IDependencyRoot).  In most cases code does not need to be in MonoBehaviours and will be resolved this way</li>
<li>If a dependency cannot be resolved, a ZenjectResolveException is thrown</li>
</ul>
<h2 id="wzxhzdk19wzxhzdk20di-rules-guidelines-recommendations"><a id="rules"></a>DI Rules / Guidelines / Recommendations</h2>
<ul>
<li>The container should <em>only</em> be referenced in the composition root layer.  Note that factories are part of this layer and the container can be referenced there (which is necessary to create objects at runtime).  For example, see ShipStateFactory in the sample project.</li>
<li>Prefer constructor injection to field or property injection.<ul>
<li>Constructor injection forces the dependency to only be resolved once, at class creation, which is usually what you want.  In many cases you don't want to expose a public property with your internal dependencies</li>
<li>Constructor injection guarantees no circular dependencies between classes, which is generally a bad thing to do</li>
<li>Constructor injection is more portable for cases where you decide to re-use the code without a DI framework such as Zenject.  You can do the same with public properties but it's more error prone.  It's possible to forget to initialize one field and leave the object in an invalid state</li>
<li>Finally, Constructor injection makes it clear what all the dependencies of a class are when another programmer is reading the code.  They can simply look at the parameter list of the constructor.</li>
</ul>
</li>
</ul>
<h2 id="wzxhzdk21wzxhzdk22tickables-iinitializables"><a id="tickables"></a>Tickables / IInitializables</h2>
<p>I prefer to avoid MonoBehaviours when possible in favour of just normal C# classes.  Zenject allows you to do this much more easily by providing interfaces that mirror functionality that you would normally need to use a MonoBehaviour for.</p>
<p>For example, if you have code that needs to run per frame, then you can implement the ITickable interface:</p>
<pre><code>public class Ship : ITickable
{
    public void Tick()
    {
        // Perform per frame tasks
    }
}
</code></pre>
<p>Then it's just a matter of including the following in one of your installers (as long as you also include a few other dependencies as outlined in the hello world example below)</p>
<pre><code>_container.Bind&lt;ITickable&gt;().ToSingle&lt;Ship&gt;();
</code></pre>
<p>The same goes for IInitializable, for cases where you have code that you want to run on startup.  (side note: using IInitializable is generally better than putting too much work in constructors).  IInitializable can also be used for objects that are created via factories (in which case Initialize() is called automatically, as long as you use one of the built in Zenject factory classes).</p>
<p>Note that you do not need to use this approach (that is, ITickables and IInitializables) to use Zenject. You can continue writing all your code in MonoBehaviours and still receive all the benefits of Zenject.</p>
<h2 id="wzxhzdk23wzxhzdk24zenject-hello-world"><a id="hello_world"></a>Zenject Hello World</h2>
<pre><code>public class TestInstallerWrapper : InstallerMonoBehaviourWrapper&lt;TestInstaller&gt;
{
}

[Serializable]
public class TestInstaller : Installer
{
    public string Name;

    public override void RegisterBindings()
    {
        Install&lt;StandardUnityInstaller&gt;();

        _container.Bind&lt;IDependencyRoot&gt;().ToSingle&lt;DependencyRootStandard&gt;();

        _container.Bind&lt;ITickable&gt;().ToSingle&lt;TestRunner&gt;();
        _container.Bind&lt;IInitializable&gt;().ToSingle&lt;TestRunner&gt;();
        _container.Bind&lt;string&gt;().ToSingle(Name).WhenInjectedInto&lt;TestRunner&gt;();
    }
}

public class TestRunner : ITickable, IInitializable
{
    string _name;

    public TestRunner(string name)
    {
        _name = name;
    }

    public void Initialize()
    {
        Debug.Log("Hello " + _name + "!");
    }

    public void Tick()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log("Exiting!");
            Application.Quit();
        }
    }
}
</code></pre>
<p>You can run this example by copying and pasting the above code into a file named 'TestInstallerWrapper'.  Then create a new scene, add a GameObject. Attach CompositionRoot to the GameObject.  Attach TestInstallerWrapper.  Run.  Observe unity console.</p>
<p>Some notes:</p>
<ul>
<li>The <code>Install&lt;StandardUnityInstaller&gt;()</code> line is necessary to tell zenject to initialize some basic unity helper classes (including the Zenject class which updates all ITickables and the class which calls Initialize on all IInitializables).  It is done this way because in some cases you might not want to use the whole ITickable/IInitializable approach at all.  Or maybe you aren't even using Unity. Etc.</li>
<li>You will also need to define a dependency root otherwise Zenject will not create your object graph</li>
<li>Note that all Installers use the [Serializable] attribute.  This is so that Installers can expose settings to their MonoBehaviour wrapper.  In this case, we expose a "Name" variable.</li>
<li>Note the usage of WhenInjectedInto.  This is good because otherwise any class which had a string parameter in its constructor would get our Name parameter.</li>
</ul>
<h2 id="wzxhzdk25wzxhzdk26update-initialization-order"><a id="update_order"></a>Update / Initialization Order</h2>
<p>In many cases, especially for small projects, the order that classes update or initialize in does not matter.  This is why Unity does not have an easy way to control this (besides in Edit -&gt; Project Settings -&gt; Script Execution Order but that is pretty awkward to use).  In Unity, after adding a bunch of MonoBehaviours to your scene, it can be difficult to predict in what order the Start(), Awake(), or Update() methods will be called in.</p>
<p>By default, ITickables and IInitializables are updated in the order that they are added, however for cases where the update or initialization order matters, there is a much better way.  By specifying their priorities explicitly in the installer.  For example, in the sample project you can find this code:</p>
<pre><code>    public override void RegisterBindings()
    {
        ...
        new TickablePrioritiesInstaller(_container, Tickables).RegisterBindings();
        new InitializablePrioritiesInstaller(_container, Initializables).RegisterBindings();
    }

    static List&lt;Type&gt; Tickables = new List&lt;Type&gt;()
    {
        // Re-arrange this list to control update order
        typeof(AsteroidManager),
        typeof(GameController),
    };

    static List&lt;Type&gt; Initializables = new List&lt;Type&gt;()
    {
        // Re-arrange this list to control init order
        typeof(GameController),
    };
</code></pre>
<p>This way, you won't hit a wall at the end of the project due to some unforseen order-dependency.</p>
<p>Any ITickables or IInitializables that aren't given an explicit order are updated after everything else.</p>
<h2 id="wzxhzdk27wzxhzdk28injecting-data-across-scenes"><a id="across_scenes"></a>Injecting data across scenes</h2>
<p>In some cases it's useful to pass arguments from one scene to another.  The way Unity allows us to do this by default is fairly awkward.  Your options are to create a persistent GameObject and call DontDestroyOnLoad() to keep it alive when changing scenes, or use global static classes to temporarily store the data.</p>
<p>Let's pretend you want to specify a 'level' string to the next scene.  You have the following class that requires the input:</p>
<pre><code>public class LevelHandler : IInitializable
{
    readonly string _startLevel;

    public LevelHandler(
        [InjectOptional]
        [Inject("StartLevelName")]
        string startLevel)
    {
        if (startLevel == null)
        {
            _startLevel = "level01";
        }
        else
        {
            _startLevel = startLevel;
        }
    }

    public void Initialize()
    {
        ...
        [Load level]
        ...
    }
}
</code></pre>
<p>You can load the scene containing <code>LessonStandaloneStart</code> and specify a particular level by using the following syntax:</p>
<pre><code>ZenUtil.LoadLevel("NameOfSceneToLoad",
    delegate (DiContainer container)
    {
        container.Bind&lt;string&gt;().ToSingle("level02").WhenInjectedInto&lt;LevelHandler&gt;("StartLevelName");
    });
</code></pre>
<p>Note that you can still run the scene directly, in which case it will default to using "level01".  This is possible because we are using the InjectOptional flag.</p>
<h2 id="wzxhzdk29wzxhzdk30auto-mocking-using-moq"><a id="automocking"></a>Auto-Mocking using Moq</h2>
<p>One of the really cool features of DI is the fact that it makes testing code much, much easier.  This is because you can easily substitute one dependency for another by using a different Composition Root.  For example, if you only want to test a particular class (let's call it Foo) and don't care about testing its dependencies, you might write 'mocks' for them so that you can isolate Foo specifically.</p>
<pre><code>public class Foo
{
    IWebServer _webServer;

    public Foo(IWebServer webServer)
    {
        _webServer = webServer;
    }

    public void Initialize()
    {
        ...
        var x = _webServer.GetSomething();
        ...
    }
}
</code></pre>
<p>In this example, we have a class Foo that interacts with a web server to retrieve content.  This would normally be very difficult to test for the following reasons:</p>
<ul>
<li>You would have to set up an environment where it can properly connect to a web server (configuring ports, urls, etc.)</li>
<li>Running the test could be slower and limit how much testing you can do</li>
<li>The web server itself could contain bugs so you couldn't with certainty isolate Foo as the problematic part of the test</li>
<li>You can't easily configure the values returned from the web server to test sending various inputs to the Foo class</li>
</ul>
<p>However, if we create a mock class for IWebServer then we can address all these problems:</p>
<pre><code>public class MockWebServer : IWebServer
{
    ...
}
</code></pre>
<p>Then hook it up in our installer:</p>
<pre><code>_container.Bind&lt;IWebServer&gt;().ToSingle&lt;MockWebServer&gt;();
</code></pre>
<p>Then you can implement the fields of the IWebServer interface and configure them based on what you want to test on Foo. Hopefully You can see how this can make life when writing tests much easier.</p>
<p>Zenject also allows you to even avoid having to write the MockWebServer class in favour of using a very useful library called "Moq" which does all the work for you.</p>
<p>Note that by default, Auto-mocking is not enabled in Zenject.  If you wish to use the auto-mocking feature then go to your Zenject install directory and extract the contents of AddOns/ZenjectAutoMocking.unitypackage to your unity project.  Note also that AutoMocking is incompatible with webplayer builds, and you will also need to change your "Api Compatibility Level" from ".NET 2.0 Subset" to ".NET 2.0" (you can find this in PC build settings)</p>
<p>After extracting the auto mocking package it is just a matter of using the following syntax to mock out various parts of your project:</p>
<pre><code>_container.Bind&lt;IFoo&gt;().ToMock();
</code></pre>
<p>However, this approach will not allow you to take advantage of the advanced features of Moq.  In order to do that, I recommend peeking in to the ToMock() method to see how that works.</p>
<h2 id="wzxhzdk31wzxhzdk32visualizing-object-graphs-automatically"><a id="graphviz"></a>Visualizing Object Graphs Automatically</h2>
<p>Zenject allows users to generate UML-style images of the object graphs for their applications.  You can do this simply by running your Zenject-driven app, then selectin from the menu <code>Assets -&gt; Zenject -&gt; Output Object Graph For Current Scene</code>.  You will be prompted for a location to save the generated image file.</p>
<p>Note that you will need to have graphviz installed for this to work (which you can find <a href="http://www.graphviz.org/">here</a>).  You will be prompted to choose the location.</p>
<p>The result is two files (Foo.dot and Foo.png).  The dot file is included in case you want to add custom graphviz commands.</p>
<h2 id="wzxhzdk33wzxhzdk34how-is-this-different-from-strange-ioc"><a id="strange"></a>How is this different from Strange IoC?</h2>
<p>Zenject is a pure dependency injection framework and does not offer the suite of features that Strange IoC does.  It is kept extremely lightweight to focus on its single purpose: Simple, reliable, and flexible dependency management.</p>
<hr />
<p>Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at</p>
<pre><code>   http://www.apache.org/licenses/LICENSE-2.0
</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.</p>
